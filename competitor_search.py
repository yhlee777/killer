# -*- coding: utf-8 -*-
# competitor_search_advanced.py - ì´ˆì •êµ ê²½ìŸì‚¬ ê²€ìƒ‰ ì‹œìŠ¤í…œ

import sqlite3
import logging
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
from enum import Enum

# ==================== ë¡œê¹… ì„¤ì • ====================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


# ==================== ë°ì´í„° í´ë˜ìŠ¤ ====================

@dataclass
class CompetitorScore:
    """ê²½ìŸì‚¬ ì ìˆ˜ ë°ì´í„°"""
    place_id: str
    name: str
    district: str
    industry: str
    review_count: int
    industry_similarity: float
    geo_fitness: float
    competition_score: float
    match_type: str = "ì •í™• ì¼ì¹˜"  # "ì •í™• ì¼ì¹˜", "ìœ ì‚¬ ì—…ì¢…", "ëŒ€ì²´ ì—…ì¢…"


class DistanceLevel(Enum):
    """ê±°ë¦¬ ë ˆë²¨"""
    SAME_STRIP = (1.00, "ë™ì¼ ìŠ¤íŠ¸ë¦½/ë‹¨ì§€")  # 0~300m
    SAME_AREA = (0.85, "ê°™ì€ ê¶Œì—­Â·ë„ë³´ 10ë¶„")  # 300~800m
    NEARBY = (0.60, "ì¸ì ‘ ê¶Œì—­Â·ë„ë³´ 15ë¶„")  # 800~1500m
    ADJACENT = (0.40, "ì¸ì ‘ ì§€ì—­Â·ëŒ€ì¤‘êµí†µ")  # 1500~3000m
    FAR = (0.20, "ë¨¼ ì§€ì—­")  # 3000m+


# ==================== ì—­ëª…/ì§€ì—­ëª… ë§¤í•‘ ====================

STATION_TO_AREA = {
    # ê°•ë‚¨ê¶Œ
    'ê°•ë‚¨ì—­': 'ê°•ë‚¨ì—­', 'ê°•ë‚¨': 'ê°•ë‚¨ì—­',
    'ì‹ ë…¼í˜„ì—­': 'ì‹ ë…¼í˜„ì—­', 'ì‹ ë…¼í˜„': 'ì‹ ë…¼í˜„ì—­',
    'ë…¼í˜„ì—­': 'ë…¼í˜„ì—­', 'ë…¼í˜„': 'ë…¼í˜„ì—­',
    'ì—­ì‚¼ì—­': 'ì—­ì‚¼', 'ì—­ì‚¼': 'ì—­ì‚¼',
    'ì„ ë¦‰ì—­': 'ì„ ë¦‰', 'ì„ ë¦‰': 'ì„ ë¦‰',
    'ì‚¼ì„±ì—­': 'ì‚¼ì„±ë™', 'ì‚¼ì„±ë™': 'ì‚¼ì„±ë™', 'ì‚¼ì„±': 'ì‚¼ì„±ë™',
    'ì••êµ¬ì •ì—­': 'ì••êµ¬ì •', 'ì••êµ¬ì •': 'ì••êµ¬ì •',
    'ì²­ë‹´ì—­': 'ì²­ë‹´', 'ì²­ë‹´': 'ì²­ë‹´',
    'ì‹ ì‚¬ì—­': 'ì‹ ì‚¬', 'ì‹ ì‚¬': 'ì‹ ì‚¬',
    'ê°€ë¡œìˆ˜ê¸¸': 'ê°€ë¡œìˆ˜ê¸¸',
    
    # í™ëŒ€/ì—°ë‚¨/í•©ì •ê¶Œ
    'í™ëŒ€ì…êµ¬ì—­': 'í™ëŒ€', 'í™ëŒ€': 'í™ëŒ€',
    'ìƒìˆ˜ì—­': 'ìƒìˆ˜', 'ìƒìˆ˜': 'ìƒìˆ˜',
    'í•©ì •ì—­': 'í•©ì •', 'í•©ì •': 'í•©ì •',
    'ì—°ë‚¨ë™': 'ì—°ë‚¨ë™', 'ì—°ë‚¨': 'ì—°ë‚¨ë™',
    'ë§ì›ì—­': 'ë§ì›ë™', 'ë§ì›ë™': 'ë§ì›ë™', 'ë§ì›': 'ë§ì›ë™',
    'ì„œêµë™': 'ì„œêµë™',
    
    # ì„±ìˆ˜/ê±´ëŒ€ê¶Œ
    'ì„±ìˆ˜ì—­': 'ì„±ìˆ˜ë™', 'ì„±ìˆ˜ë™': 'ì„±ìˆ˜ë™', 'ì„±ìˆ˜': 'ì„±ìˆ˜ë™',
    'ì„±ìˆ˜2ê°€': 'ì„±ìˆ˜2ê°€',
    'ê±´ëŒ€ì…êµ¬ì—­': 'ê±´ëŒ€', 'ê±´ëŒ€': 'ê±´ëŒ€',
    'ëšì„¬ì—­': 'ëšì„¬', 'ëšì„¬': 'ëšì„¬',
    'ì•„ì°¨ì‚°ì—­': 'ì•„ì°¨ì‚°', 'ì•„ì°¨ì‚°': 'ì•„ì°¨ì‚°',
    
    # ì´íƒœì›/í•œë‚¨ê¶Œ
    'ì´íƒœì›ì—­': 'ì´íƒœì›', 'ì´íƒœì›': 'ì´íƒœì›',
    'í•œë‚¨ë™': 'í•œë‚¨ë™', 'í•œë‚¨': 'í•œë‚¨ë™',
    'ê²½ë¦¬ë‹¨ê¸¸': 'ê²½ë¦¬ë‹¨ê¸¸',
    'í•´ë°©ì´Œ': 'í•´ë°©ì´Œ',
    
    # ì‹ ì´Œ/ì´ëŒ€ê¶Œ
    'ì‹ ì´Œì—­': 'ì‹ ì´Œ', 'ì‹ ì´Œ': 'ì‹ ì´Œ',
    'ì´ëŒ€ì—­': 'ì´ëŒ€', 'ì´ëŒ€': 'ì´ëŒ€', 'ì´í™”ì—¬ëŒ€': 'ì´ëŒ€',
    
    # ì ì‹¤/ì†¡íŒŒê¶Œ
    'ì ì‹¤ì—­': 'ì ì‹¤', 'ì ì‹¤': 'ì ì‹¤',
    'ì†¡íŒŒì—­': 'ì†¡íŒŒ', 'ì†¡íŒŒ': 'ì†¡íŒŒ',
    'ë°©ì´ì—­': 'ë°©ì´ë™', 'ë°©ì´ë™': 'ë°©ì´ë™', 'ë°©ì´': 'ë°©ì´ë™',
    'ê°€ë½ì‹œì¥ì—­': 'ê°€ë½', 'ê°€ë½': 'ê°€ë½',
    'ë¬¸ì •ì—­': 'ë¬¸ì •', 'ë¬¸ì •': 'ë¬¸ì •',
    'ì˜¤ê¸ˆì—­': 'ì˜¤ê¸ˆ', 'ì˜¤ê¸ˆ': 'ì˜¤ê¸ˆ',
    'ì„ì´Œì—­': 'ì„ì´Œ', 'ì„ì´Œ': 'ì„ì´Œ',
    
    # ì—¬ì˜ë„/ì˜ë“±í¬ê¶Œ
    'ì—¬ì˜ë„ì—­': 'ì—¬ì˜ë„', 'ì—¬ì˜ë„': 'ì—¬ì˜ë„',
    'ì˜ë“±í¬ì—­': 'ì˜ë“±í¬', 'ì˜ë“±í¬': 'ì˜ë“±í¬',
    'ë‹¹ì‚°ì—­': 'ë‹¹ì‚°', 'ë‹¹ì‚°': 'ë‹¹ì‚°',
    'ì„ ìœ ë„ì—­': 'ì„ ìœ ë„', 'ì„ ìœ ë„': 'ì„ ìœ ë„',
    
    # í˜œí™”/ì„±ì‹ ì—¬ëŒ€ê¶Œ
    'í˜œí™”ì—­': 'í˜œí™”', 'í˜œí™”': 'í˜œí™”',
    'ì„±ì‹ ì—¬ëŒ€ì…êµ¬ì—­': 'ì„±ì‹ ì—¬ëŒ€', 'ì„±ì‹ ì—¬ëŒ€': 'ì„±ì‹ ì—¬ëŒ€',
    'í•œì„±ëŒ€ì…êµ¬ì—­': 'í•œì„±ëŒ€', 'í•œì„±ëŒ€': 'í•œì„±ëŒ€',
    
    # ì¢…ë¡œ/ê´‘í™”ë¬¸ê¶Œ
    'ì¢…ë¡œ': 'ì¢…ë¡œ', 'ê´‘í™”ë¬¸': 'ê´‘í™”ë¬¸',
    'ëª…ë™': 'ëª…ë™', 'ì„ì§€ë¡œ': 'ì„ì§€ë¡œ',
    'ìµì„ ë™': 'ìµì„ ë™', 'ì‚¼ì²­ë™': 'ì‚¼ì²­ë™',
    'ì¸ì‚¬ë™': 'ì¸ì‚¬ë™', 'ë¶ì´Œ': 'ë¶ì´Œ',
    
    # ìš©ì‚°ê¶Œ
    'ìš©ì‚°ì—­': 'ìš©ì‚°', 'ìš©ì‚°': 'ìš©ì‚°',
    'ë…¹ì‚¬í‰ì—­': 'ë…¹ì‚¬í‰', 'ë…¹ì‚¬í‰': 'ë…¹ì‚¬í‰',
    
    # ë§ˆí¬ê¶Œ
    'ë§ˆí¬ì—­': 'ë§ˆí¬', 'ë§ˆí¬': 'ë§ˆí¬',
    'ê³µë•ì—­': 'ê³µë•', 'ê³µë•': 'ê³µë•',
    
    # ì„œìš¸ëŒ€/ì‹ ë¦¼ê¶Œ
    'ì„œìš¸ëŒ€ì…êµ¬ì—­': 'ì„œìš¸ëŒ€', 'ì„œìš¸ëŒ€': 'ì„œìš¸ëŒ€',
    'ì‹ ë¦¼ì—­': 'ì‹ ë¦¼', 'ì‹ ë¦¼': 'ì‹ ë¦¼',
    
    # ê°•ë™ê¶Œ
    'ì²œí˜¸ì—­': 'ì²œí˜¸', 'ì²œí˜¸': 'ì²œí˜¸',
    'ê°•ë™êµ¬ì²­ì—­': 'ê°•ë™', 'ê°•ë™': 'ê°•ë™',
}


# ==================== ì§€ì—­ ê·¸ë£¹ (ì„¸ë°€í™”) ====================

AREA_GROUPS = {
    'ê°•ë‚¨í•µì‹¬': ['ê°•ë‚¨ì—­', 'ì‹ ë…¼í˜„ì—­', 'ë…¼í˜„ì—­'],
    'ê°•ë‚¨ë™ë¶€': ['ì—­ì‚¼', 'ì„ ë¦‰', 'ì‚¼ì„±ë™'],
    'ê°•ë‚¨ë¶ë¶€': ['ì••êµ¬ì •', 'ì²­ë‹´', 'ì‹ ì‚¬', 'ê°€ë¡œìˆ˜ê¸¸'],
    
    'í™ëŒ€í•µì‹¬': ['í™ëŒ€', 'ìƒìˆ˜', 'ì„œêµë™'],
    'í™ëŒ€í™•ì¥': ['í•©ì •', 'ì—°ë‚¨ë™', 'ë§ì›ë™'],
    
    'ì„±ìˆ˜í•µì‹¬': ['ì„±ìˆ˜ë™', 'ì„±ìˆ˜2ê°€'],
    'ê±´ëŒ€ê¶Œ': ['ê±´ëŒ€', 'ëšì„¬', 'ì•„ì°¨ì‚°'],
    
    'ì´íƒœì›í•µì‹¬': ['ì´íƒœì›', 'ê²½ë¦¬ë‹¨ê¸¸', 'í•´ë°©ì´Œ'],
    'í•œë‚¨ê¶Œ': ['í•œë‚¨ë™'],
    
    'ì‹ ì´Œì´ëŒ€': ['ì‹ ì´Œ', 'ì´ëŒ€'],
    
    'ì ì‹¤í•µì‹¬': ['ì ì‹¤', 'ì„ì´Œ'],
    'ì†¡íŒŒê¶Œ': ['ì†¡íŒŒ', 'ë°©ì´ë™', 'ê°€ë½', 'ë¬¸ì •', 'ì˜¤ê¸ˆ'],
    
    'ì—¬ì˜ë„í•µì‹¬': ['ì—¬ì˜ë„'],
    'ì˜ë“±í¬ê¶Œ': ['ì˜ë“±í¬', 'ë‹¹ì‚°', 'ì„ ìœ ë„'],
    
    'í˜œí™”ì„±ì‹ ': ['í˜œí™”', 'ì„±ì‹ ì—¬ëŒ€', 'í•œì„±ëŒ€'],
    
    'ì¢…ë¡œí•µì‹¬': ['ì¢…ë¡œ', 'ê´‘í™”ë¬¸', 'ëª…ë™'],
    'ì¢…ë¡œí™•ì¥': ['ì„ì§€ë¡œ', 'ìµì„ ë™', 'ì‚¼ì²­ë™', 'ì¸ì‚¬ë™', 'ë¶ì´Œ'],
    
    'ìš©ì‚°ê¶Œ': ['ìš©ì‚°', 'ë…¹ì‚¬í‰'],
    'ë§ˆí¬ê¶Œ': ['ë§ˆí¬', 'ê³µë•'],
    'ì„œìš¸ëŒ€ì‹ ë¦¼': ['ì„œìš¸ëŒ€', 'ì‹ ë¦¼'],
    'ê°•ë™ê¶Œ': ['ì²œí˜¸', 'ê°•ë™'],
}


# ==================== ì—…ì¢… ê³„ì¸µ êµ¬ì¡° (í´ë°± ì²´ì¸) ====================

INDUSTRY_HIERARCHY = {
    # === ì¹´í˜/ë””ì €íŠ¸ ===
    'ì¹´í˜': ['ì¹´í˜'],
    'ë””ì €íŠ¸ì¹´í˜': ['ì¹´í˜', 'ë””ì €íŠ¸ì¹´í˜'],
    'ë¸ŒëŸ°ì¹˜ì¹´í˜': ['ì¹´í˜', 'ë¸ŒëŸ°ì¹˜ì¹´í˜'],
    'ë² ì´ì»¤ë¦¬': ['ë² ì´ì»¤ë¦¬', 'ì¹´í˜'],
    'ë„ë„›': ['ë² ì´ì»¤ë¦¬', 'ë””ì €íŠ¸ì¹´í˜', 'ì¹´í˜'],
    'ì™€í”Œ': ['ë””ì €íŠ¸ì¹´í˜', 'ì¹´í˜'],
    'ë§ˆì¹´ë¡±': ['ë””ì €íŠ¸ì¹´í˜', 'ë² ì´ì»¤ë¦¬', 'ì¹´í˜'],
    
    # === ì°œ/íƒ• ìš”ë¦¬ ===
    'ì•„ê·€ì°œ': ['ì•„ê·€ì°œ', 'í•´ë¬¼ì°œ', 'ì°œë¥˜', 'í•´ë¬¼ìš”ë¦¬', 'í•œì‹', 'ìŒì‹ì '],
    'í•´ë¬¼ì°œ': ['í•´ë¬¼ì°œ', 'ì°œë¥˜', 'í•´ë¬¼ìš”ë¦¬', 'í•œì‹', 'ìŒì‹ì '],
    'ê°ˆë¹„ì°œ': ['ê°ˆë¹„ì°œ', 'ì°œë¥˜', 'ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ì°œë‹­': ['ì°œë‹­', 'ì°œë¥˜', 'ë‹­ìš”ë¦¬', 'í•œì‹', 'ìŒì‹ì '],
    'ê°ìíƒ•': ['ê°ìíƒ•', 'íƒ•ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'í•´ë¬¼íƒ•': ['í•´ë¬¼íƒ•', 'íƒ•ë¥˜', 'í•´ë¬¼ìš”ë¦¬', 'í•œì‹', 'ìŒì‹ì '],
    
    # === ì¼ì‹ (ì„¸ë°€í™”) ===
    'ì˜¤ë§ˆì¹´ì„¸': ['ì˜¤ë§ˆì¹´ì„¸', 'ìŠ¤ì‹œ', 'ì¼ì‹', 'ìŒì‹ì '],
    'ìŠ¤ì‹œ': ['ìŠ¤ì‹œ', 'ì¼ì‹', 'ìŒì‹ì '],
    'ì´ìì¹´ì•¼': ['ì´ìì¹´ì•¼', 'ì¼ì‹', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'ìŒì‹ì '],
    'ë¼ë©˜': ['ë¼ë©˜', 'ì¼ì‹', 'ìŒì‹ì '],
    'ìš°ë™': ['ìš°ë™', 'ë¼ë©˜', 'ì¼ì‹', 'ìŒì‹ì '],
    'ëˆì¹´ì¸ ': ['ëˆì¹´ì¸ ', 'ì¼ì‹', 'ìŒì‹ì '],
    'ì†Œë°”': ['ì†Œë°”', 'ìš°ë™', 'ì¼ì‹', 'ìŒì‹ì '],
    'ì•¼í‚¤í† ë¦¬': ['ì•¼í‚¤í† ë¦¬', 'ì´ìì¹´ì•¼', 'ì¼ì‹', 'ìˆ ì§‘', 'ìŒì‹ì '],
    'íšŒ': ['íšŒ', 'ìŠ¤ì‹œ', 'ì¼ì‹', 'ìŒì‹ì '],
    
    # === ì–‘ì‹ ===
    'íŒŒìŠ¤íƒ€': ['íŒŒìŠ¤íƒ€', 'ì´íƒˆë¦¬ì•ˆ', 'ì–‘ì‹', 'ìŒì‹ì '],
    'ì´íƒˆë¦¬ì•ˆ': ['ì´íƒˆë¦¬ì•ˆ', 'ì–‘ì‹', 'ìŒì‹ì '],
    'í”¼ì': ['í”¼ì', 'ì´íƒˆë¦¬ì•ˆ', 'ì–‘ì‹', 'ìŒì‹ì '],
    'ìŠ¤í…Œì´í¬': ['ìŠ¤í…Œì´í¬', 'ì–‘ì‹', 'ìœ¡ë¥˜', 'ìŒì‹ì '],
    'ë²„ê±°': ['ë²„ê±°', 'ì–‘ì‹', 'ìŒì‹ì '],
    'ìƒŒë“œìœ„ì¹˜': ['ìƒŒë“œìœ„ì¹˜', 'ë¸ŒëŸ°ì¹˜', 'ì¹´í˜', 'ì–‘ì‹', 'ìŒì‹ì '],
    'ë¸ŒëŸ°ì¹˜': ['ë¸ŒëŸ°ì¹˜', 'ì¹´í˜', 'ì–‘ì‹', 'ìŒì‹ì '],
    
    # === ì¤‘ì‹ ===
    'ë§ˆë¼íƒ•': ['ë§ˆë¼íƒ•', 'ì¤‘ì‹', 'ìŒì‹ì '],
    'ë”¤ì„¬': ['ë”¤ì„¬', 'ì¤‘ì‹', 'ìŒì‹ì '],
    'ì¤‘ì‹': ['ì¤‘ì‹', 'ìŒì‹ì '],
    'ì¤‘êµ­ì§‘': ['ì¤‘ì‹', 'ìŒì‹ì '],
    'í› ê¶ˆ': ['í› ê¶ˆ', 'ë§ˆë¼íƒ•', 'ì¤‘ì‹', 'ìŒì‹ì '],
    
    # === ì•„ì‹œì•ˆ ===
    'ìŒ€êµ­ìˆ˜': ['ìŒ€êµ­ìˆ˜', 'ë² íŠ¸ë‚¨ìŒì‹', 'ì•„ì‹œì•ˆ', 'ìŒì‹ì '],
    'ë² íŠ¸ë‚¨ìŒì‹': ['ë² íŠ¸ë‚¨ìŒì‹', 'ì•„ì‹œì•ˆ', 'ìŒì‹ì '],
    'íƒœêµ­ìŒì‹': ['íƒœêµ­ìŒì‹', 'ì•„ì‹œì•ˆ', 'ìŒì‹ì '],
    'íŒŸíƒ€ì´': ['íŒŸíƒ€ì´', 'íƒœêµ­ìŒì‹', 'ì•„ì‹œì•ˆ', 'ìŒì‹ì '],
    
    # === í•œì‹ (ì„¸ë°€í™”) ===
    'í•œì •ì‹': ['í•œì •ì‹', 'í•œì‹', 'ìŒì‹ì '],
    'í•œì‹ë‹¹': ['í•œì‹', 'ìŒì‹ì '],
    'í•œì‹': ['í•œì‹', 'ìŒì‹ì '],
    'ê³ ê¸°ì§‘': ['ê³ ê¸°ì§‘', 'ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ì‚¼ê²¹ì‚´': ['ì‚¼ê²¹ì‚´', 'ê³ ê¸°ì§‘', 'ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ê°ˆë¹„': ['ê°ˆë¹„', 'ê³ ê¸°ì§‘', 'ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ê³±ì°½': ['ê³±ì°½', 'ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ì¡±ë°œ': ['ì¡±ë°œ', 'í•œì‹', 'ìŒì‹ì '],
    'ë³´ìŒˆ': ['ë³´ìŒˆ', 'ì¡±ë°œ', 'í•œì‹', 'ìŒì‹ì '],
    'ìœ¡ë¥˜': ['ìœ¡ë¥˜', 'í•œì‹', 'ìŒì‹ì '],
    'ë‹­ìš”ë¦¬': ['ë‹­ìš”ë¦¬', 'í•œì‹', 'ìŒì‹ì '],
    'ì¹˜í‚¨': ['ì¹˜í‚¨', 'ë‹­ìš”ë¦¬', 'ìŒì‹ì '],
    
    # === ìˆ ì§‘ (í†µí•© ê·¸ë£¹) ===
    'ìˆ ì§‘': ['ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'í˜¸í”„ì§‘', 'ë°”', 'í', 'í¬ì°¨', 'ìŒì‹ì '],
    'ì£¼ì ': ['ì£¼ì ', 'ìˆ ì§‘', 'ìš”ë¦¬ì£¼ì ', 'í˜¸í”„ì§‘', 'ë°”', 'í', 'í¬ì°¨', 'ìŒì‹ì '],
    'ìš”ë¦¬ì£¼ì ': ['ìš”ë¦¬ì£¼ì ', 'ì£¼ì ', 'ìˆ ì§‘', 'í˜¸í”„ì§‘', 'ë°”', 'í', 'í¬ì°¨', 'ìŒì‹ì '],
    'í˜¸í”„ì§‘': ['í˜¸í”„ì§‘', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'ë°”', 'í', 'í¬ì°¨', 'ìŒì‹ì '],
    'ë°”': ['ë°”', 'ì™€ì¸ë°”', 'ì¹µí…Œì¼ë°”', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'í', 'ìŒì‹ì '],
    'í': ['í', 'ë°”', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'í˜¸í”„ì§‘', 'í¬ì°¨', 'ìŒì‹ì '],
    'í¬ì°¨': ['í¬ì°¨', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'í˜¸í”„ì§‘', 'ìŒì‹ì '],
    'ì™€ì¸ë°”': ['ì™€ì¸ë°”', 'ë°”', 'ì¹µí…Œì¼ë°”', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'ìŒì‹ì '],
    'ì¹µí…Œì¼ë°”': ['ì¹µí…Œì¼ë°”', 'ë°”', 'ì™€ì¸ë°”', 'ìˆ ì§‘', 'ì£¼ì ', 'ìš”ë¦¬ì£¼ì ', 'ìŒì‹ì '],
    
    # === ê¸°íƒ€ ===
    'ë·”í˜': ['ë·”í˜', 'ìŒì‹ì '],
    'ìƒ¤ë¸Œìƒ¤ë¸Œ': ['ìƒ¤ë¸Œìƒ¤ë¸Œ', 'ì¼ì‹', 'ìŒì‹ì '],
}


# ==================== ì—…ì¢… ìœ ì‚¬ë„ ë§¤í•‘ (ëŒ€í­ í™•ì¥) ====================

INDUSTRY_SIMILARITY = {
    # === ì¹´í˜/ë””ì €íŠ¸ (1.00 = ë™ì¼, 0.85 = ê±°ì˜ ê°™ìŒ, 0.75 = ì„¸ë¶€ ì°¨ì´, 0.60 = ì¸ì ‘, 0.40 = ì•½í•œ ëŒ€ì²´) ===
    ('ì¹´í˜', 'ì¹´í˜'): 1.00,
    ('ì¹´í˜', 'ë””ì €íŠ¸ì¹´í˜'): 0.85,
    ('ì¹´í˜', 'ë¸ŒëŸ°ì¹˜ì¹´í˜'): 0.85,
    ('ë””ì €íŠ¸ì¹´í˜', 'ë¸ŒëŸ°ì¹˜ì¹´í˜'): 0.75,
    ('ì¹´í˜', 'ë² ì´ì»¤ë¦¬'): 0.75,
    ('ë””ì €íŠ¸ì¹´í˜', 'ë² ì´ì»¤ë¦¬'): 0.85,
    ('ë² ì´ì»¤ë¦¬', 'ë„ë„›'): 0.85,
    ('ë² ì´ì»¤ë¦¬', 'ë§ˆì¹´ë¡±'): 0.75,
    ('ì¹´í˜', 'ì™€í”Œ'): 0.75,
    ('ì¹´í˜', 'ìƒŒë“œìœ„ì¹˜'): 0.60,
    ('ë¸ŒëŸ°ì¹˜ì¹´í˜', 'ìƒŒë“œìœ„ì¹˜'): 0.75,
    ('ì¹´í˜', 'ë²„ê±°'): 0.40,
    
    # === ì°œ/íƒ•ë¥˜ ===
    ('ì•„ê·€ì°œ', 'ì•„ê·€ì°œ'): 1.00,
    ('ì•„ê·€ì°œ', 'í•´ë¬¼ì°œ'): 0.85,
    ('í•´ë¬¼ì°œ', 'í•´ë¬¼ì°œ'): 1.00,
    ('ê°ˆë¹„ì°œ', 'ê°ˆë¹„ì°œ'): 1.00,
    ('ì°œë‹­', 'ì°œë‹­'): 1.00,
    ('ì•„ê·€ì°œ', 'ê°ˆë¹„ì°œ'): 0.60,  # ê°™ì€ 'ì°œ' ì¹´í…Œê³ ë¦¬
    ('í•´ë¬¼ì°œ', 'í•´ë¬¼íƒ•'): 0.75,
    ('ê°ˆë¹„ì°œ', 'ê°ˆë¹„'): 0.70,
    ('ê°ìíƒ•', 'ê°ìíƒ•'): 1.00,
    ('ê°ìíƒ•', 'í•´ë¬¼íƒ•'): 0.60,  # ê°™ì€ 'íƒ•' ì¹´í…Œê³ ë¦¬
    
    # === ì¼ì‹ ===
    ('ì˜¤ë§ˆì¹´ì„¸', 'ì˜¤ë§ˆì¹´ì„¸'): 1.00,
    ('ì˜¤ë§ˆì¹´ì„¸', 'ìŠ¤ì‹œ'): 0.85,
    ('ìŠ¤ì‹œ', 'ìŠ¤ì‹œ'): 1.00,
    ('ìŠ¤ì‹œ', 'íšŒ'): 0.75,
    ('ì´ìì¹´ì•¼', 'ì´ìì¹´ì•¼'): 1.00,
    ('ì´ìì¹´ì•¼', 'ì•¼í‚¤í† ë¦¬'): 0.85,
    ('ì´ìì¹´ì•¼', 'ìˆ ì§‘'): 0.75,
    ('ì´ìì¹´ì•¼', 'ì£¼ì '): 0.75,
    ('ì´ìì¹´ì•¼', 'ìš”ë¦¬ì£¼ì '): 0.80,
    ('ì´ìì¹´ì•¼', 'ë°”'): 0.65,
    ('ë¼ë©˜', 'ë¼ë©˜'): 1.00,
    ('ë¼ë©˜', 'ìš°ë™'): 0.85,
    ('ìš°ë™', 'ì†Œë°”'): 0.85,
    ('ëˆì¹´ì¸ ', 'ëˆì¹´ì¸ '): 1.00,
    ('ì˜¤ë§ˆì¹´ì„¸', 'ì´ìì¹´ì•¼'): 0.60,
    ('ë¼ë©˜', 'ëˆì¹´ì¸ '): 0.60,
    
    # === ì–‘ì‹ ===
    ('íŒŒìŠ¤íƒ€', 'íŒŒìŠ¤íƒ€'): 1.00,
    ('íŒŒìŠ¤íƒ€', 'ì´íƒˆë¦¬ì•ˆ'): 0.85,
    ('ì´íƒˆë¦¬ì•ˆ', 'ì´íƒˆë¦¬ì•ˆ'): 1.00,
    ('ì´íƒˆë¦¬ì•ˆ', 'í”¼ì'): 0.85,
    ('íŒŒìŠ¤íƒ€', 'í”¼ì'): 0.75,
    ('ìŠ¤í…Œì´í¬', 'ìŠ¤í…Œì´í¬'): 1.00,
    ('íŒŒìŠ¤íƒ€', 'ìŠ¤í…Œì´í¬'): 0.60,
    ('ë²„ê±°', 'ë²„ê±°'): 1.00,
    ('ë²„ê±°', 'ìƒŒë“œìœ„ì¹˜'): 0.75,
    ('íŒŒìŠ¤íƒ€', 'ë²„ê±°'): 0.50,
    
    # === ì¤‘ì‹ ===
    ('ë§ˆë¼íƒ•', 'ë§ˆë¼íƒ•'): 1.00,
    ('ë§ˆë¼íƒ•', 'í› ê¶ˆ'): 0.85,
    ('ë”¤ì„¬', 'ë”¤ì„¬'): 1.00,
    ('ë§ˆë¼íƒ•', 'ë”¤ì„¬'): 0.60,
    ('ë§ˆë¼íƒ•', 'ì¤‘ì‹'): 0.75,
    
    # === í•œì‹ ===
    ('í•œì •ì‹', 'í•œì •ì‹'): 1.00,
    ('í•œì‹', 'í•œì‹'): 1.00,
    ('í•œì •ì‹', 'í•œì‹'): 0.85,
    ('ê³ ê¸°ì§‘', 'ê³ ê¸°ì§‘'): 1.00,
    ('ì‚¼ê²¹ì‚´', 'ì‚¼ê²¹ì‚´'): 1.00,
    ('ì‚¼ê²¹ì‚´', 'ê°ˆë¹„'): 0.85,
    ('ì‚¼ê²¹ì‚´', 'ê³ ê¸°ì§‘'): 0.85,
    ('ê³±ì°½', 'ê³±ì°½'): 1.00,
    ('ê³±ì°½', 'ê³ ê¸°ì§‘'): 0.70,
    ('ì¡±ë°œ', 'ë³´ìŒˆ'): 0.85,
    ('ì¡±ë°œ', 'í•œì‹'): 0.75,
    ('ì¹˜í‚¨', 'ë‹­ìš”ë¦¬'): 0.85,
    ('í•œì‹', 'ê³ ê¸°ì§‘'): 0.70,
    
    # === ìˆ ì§‘ (í†µí•© ê·¸ë£¹ - ëª¨ë‘ ë†’ì€ ìœ ì‚¬ë„) ===
    ('ìˆ ì§‘', 'ìˆ ì§‘'): 1.00,
    ('ì£¼ì ', 'ì£¼ì '): 1.00,
    ('ìš”ë¦¬ì£¼ì ', 'ìš”ë¦¬ì£¼ì '): 1.00,
    ('í˜¸í”„ì§‘', 'í˜¸í”„ì§‘'): 1.00,
    ('ë°”', 'ë°”'): 1.00,
    ('í', 'í'): 1.00,
    ('í¬ì°¨', 'í¬ì°¨'): 1.00,
    ('ì™€ì¸ë°”', 'ì™€ì¸ë°”'): 1.00,
    ('ì¹µí…Œì¼ë°”', 'ì¹µí…Œì¼ë°”'): 1.00,
    # ìˆ ì§‘ ê³„ì—´ ìƒí˜¸ ìœ ì‚¬ë„ (0.85~0.90 = ê±°ì˜ ë™ì¼ ì—…ì¢…ìœ¼ë¡œ ì·¨ê¸‰)
    ('ìˆ ì§‘', 'ì£¼ì '): 0.90,
    ('ìˆ ì§‘', 'ìš”ë¦¬ì£¼ì '): 0.90,
    ('ìˆ ì§‘', 'í˜¸í”„ì§‘'): 0.85,
    ('ì£¼ì ', 'ìš”ë¦¬ì£¼ì '): 0.90,
    ('ì£¼ì ', 'í˜¸í”„ì§‘'): 0.85,
    ('ìš”ë¦¬ì£¼ì ', 'í˜¸í”„ì§‘'): 0.85,
    ('ìˆ ì§‘', 'ë°”'): 0.80,
    ('ìˆ ì§‘', 'í'): 0.85,
    ('ì£¼ì ', 'ë°”'): 0.80,
    ('ì£¼ì ', 'í'): 0.85,
    ('ìš”ë¦¬ì£¼ì ', 'ë°”'): 0.80,
    ('ìš”ë¦¬ì£¼ì ', 'í'): 0.85,
    ('í˜¸í”„ì§‘', 'ë°”'): 0.75,
    ('í˜¸í”„ì§‘', 'í'): 0.85,
    ('ë°”', 'í'): 0.85,
    ('ìˆ ì§‘', 'í¬ì°¨'): 0.85,
    ('ì£¼ì ', 'í¬ì°¨'): 0.85,
    ('ìš”ë¦¬ì£¼ì ', 'í¬ì°¨'): 0.80,
    # íŠ¹ìˆ˜ ë°” (ì™€ì¸ë°”, ì¹µí…Œì¼ë°”)
    ('ì™€ì¸ë°”', 'ì¹µí…Œì¼ë°”'): 0.85,
    ('ì™€ì¸ë°”', 'ë°”'): 0.85,
    ('ì¹µí…Œì¼ë°”', 'ë°”'): 0.85,
    ('ì™€ì¸ë°”', 'ìˆ ì§‘'): 0.75,
    ('ì¹µí…Œì¼ë°”', 'ìˆ ì§‘'): 0.75,
    ('ì™€ì¸ë°”', 'ì£¼ì '): 0.70,
    ('ì¹µí…Œì¼ë°”', 'ì£¼ì '): 0.70,
    
    # === í¬ë¡œìŠ¤ ì¹´í…Œê³ ë¦¬ (ì•½í•œ ëŒ€ì²´) ===
    ('ì¹´í˜', 'í•œì‹'): 0.20,
    ('ì¹´í˜', 'ì¼ì‹'): 0.20,
    ('ì¼ì‹', 'í•œì‹'): 0.40,
    ('ì¼ì‹', 'ì¤‘ì‹'): 0.40,
    ('ì–‘ì‹', 'í•œì‹'): 0.40,
}


def get_industry_similarity_score(industry1: str, industry2: str) -> float:
    """
    ì—…ì¢… ìœ ì‚¬ë„ ì ìˆ˜ ê³„ì‚° (0~1)
    
    ìš°ì„ ìˆœìœ„:
    1. ì§ì ‘ ë§¤í•‘ ì²´í¬ (INDUSTRY_SIMILARITY)
    2. ê°™ì€ í´ë°± ì²´ì¸ì— ìˆëŠ”ì§€ ì²´í¬
    3. í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ë¡ 
    4. ê¸°ë³¸ê°’ 0.0
    """
    if industry1 == industry2:
        return 1.00
    
    # ì–‘ë°©í–¥ ì²´í¬
    key1 = (industry1, industry2)
    key2 = (industry2, industry1)
    
    if key1 in INDUSTRY_SIMILARITY:
        return INDUSTRY_SIMILARITY[key1]
    if key2 in INDUSTRY_SIMILARITY:
        return INDUSTRY_SIMILARITY[key2]
    
    # í´ë°± ì²´ì¸ ì²´í¬
    chain1 = INDUSTRY_HIERARCHY.get(industry1, [industry1])
    chain2 = INDUSTRY_HIERARCHY.get(industry2, [industry2])
    
    # ì²´ì¸ ê°„ ê²¹ì¹˜ëŠ” ì •ë„ë¡œ ìœ ì‚¬ë„ ì¶”ì •
    overlap = set(chain1) & set(chain2)
    if overlap:
        # ê²¹ì¹˜ëŠ” ìœ„ì¹˜ê°€ ë¹ ë¥¼ìˆ˜ë¡ ìœ ì‚¬ë„ ë†’ìŒ
        min_idx1 = min([chain1.index(item) for item in overlap])
        min_idx2 = min([chain2.index(item) for item in overlap])
        avg_idx = (min_idx1 + min_idx2) / 2
        
        # ì¸ë±ìŠ¤ê°€ ë‚®ì„ìˆ˜ë¡ ìœ ì‚¬ (0â†’1.0, 1â†’0.75, 2â†’0.6, 3â†’0.5...)
        if avg_idx == 0:
            return 0.85
        elif avg_idx <= 1:
            return 0.70
        elif avg_idx <= 2:
            return 0.55
        elif avg_idx <= 3:
            return 0.40
        else:
            return 0.25
    
    # í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ë¡ 
    keywords_match = {
        'ì¹´í˜': 0.30,
        'í•œì‹': 0.40,
        'ì¼ì‹': 0.40,
        'ì–‘ì‹': 0.40,
        'ì¤‘ì‹': 0.40,
        'ìˆ ì§‘': 0.40,
        'ë°”': 0.40,
    }
    
    for keyword, score in keywords_match.items():
        if keyword in industry1 and keyword in industry2:
            return score
    
    # ì™„ì „ ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬
    return 0.00


# ==================== ì§€ì—­ ì í•©ë„ ê³„ì‚° ====================

def get_geo_fitness_score(area1: str, area2: str, has_barrier: bool = False) -> float:
    """
    ì§€ì—­ ì í•©ë„ ì ìˆ˜ ê³„ì‚° (0~1)
    
    Returns:
        float: ì§€ì—­ ì í•©ë„ (0~1)
    """
    if area1 == area2:
        return DistanceLevel.SAME_STRIP.value[0]
    
    # ê°™ì€ ê·¸ë£¹ ë‚´ í™•ì¸
    for group_name, areas in AREA_GROUPS.items():
        if area1 in areas and area2 in areas:
            # í•µì‹¬ ê·¸ë£¹ì´ë©´ SAME_AREA, í™•ì¥ ê·¸ë£¹ì´ë©´ NEARBY
            if 'í•µì‹¬' in group_name:
                score = DistanceLevel.SAME_AREA.value[0]
            else:
                score = DistanceLevel.NEARBY.value[0]
            
            # ì¥ë²½ íŒ¨ë„í‹°
            if has_barrier:
                score *= 0.75
            return score
    
    # ì¸ì ‘ ê·¸ë£¹ í™•ì¸ (ì˜ˆ: ê°•ë‚¨í•µì‹¬ vs ê°•ë‚¨ë™ë¶€)
    group1 = None
    group2 = None
    
    for group_name, areas in AREA_GROUPS.items():
        if area1 in areas:
            group1 = group_name
        if area2 in areas:
            group2 = group_name
    
    if group1 and group2:
        # ê°™ì€ ëŒ€ë¶„ë¥˜ (ì˜ˆ: ê°•ë‚¨í•µì‹¬ vs ê°•ë‚¨ë¶ë¶€)
        prefix1 = group1.split('í•µì‹¬')[0].split('ê¶Œ')[0].split('í™•ì¥')[0]
        prefix2 = group2.split('í•µì‹¬')[0].split('ê¶Œ')[0].split('í™•ì¥')[0]
        
        if prefix1 == prefix2:
            score = DistanceLevel.NEARBY.value[0]
            if has_barrier:
                score *= 0.75
            return score
    
    # ë‹¤ë¥¸ ê¶Œì—­
    score = DistanceLevel.ADJACENT.value[0]
    if has_barrier:
        score *= 0.60  # ë‹¤ë¥¸ ê¶Œì—­ì€ ì¥ë²½ íŒ¨ë„í‹° ë” í¼
    
    return score


# ==================== ê²½ìŸ ì ìˆ˜ ê³„ì‚° ====================

def calculate_competition_score(
    industry_similarity: float,
    geo_fitness: float,
    beta: float = 1.8,
    alpha: float = 0.9
) -> float:
    """
    ìµœì¢… ê²½ìŸ ì ìˆ˜ = (ì—…ì¢… ìœ ì‚¬ë„)^Î² Ã— (ì§€ì—­ ì í•©ë„)^Î±
    """
    try:
        return (industry_similarity ** beta) * (geo_fitness ** alpha)
    except Exception as e:
        logger.error(f"ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
        return 0.0


# ==================== ì§€ì—­ëª… ì •ê·œí™” ====================

def normalize_area(user_input: str) -> str:
    """ì‚¬ìš©ì ì…ë ¥ ì§€ì—­ëª… í‘œì¤€í™”"""
    if not user_input:
        return ""
    
    user_input = user_input.strip()
    
    # ì§ì ‘ ë§¤í•‘
    if user_input in STATION_TO_AREA:
        return STATION_TO_AREA[user_input]
    
    # ì ‘ë¯¸ì‚¬ ì œê±° í›„ ì¬ì‹œë„
    for suffix in ['ì—­', 'ë™', 'êµ¬', 'ë¡œ']:
        if user_input.endswith(suffix):
            base = user_input[:-len(suffix)]
            if base in STATION_TO_AREA:
                return STATION_TO_AREA[base]
    
    # í¬í•¨ ê²€ìƒ‰ (ë¶€ë¶„ ë§¤ì¹­)
    for key, value in STATION_TO_AREA.items():
        if user_input in key or key in user_input:
            return value
    
    # ëª» ì°¾ìœ¼ë©´ ì›ë³¸ ë°˜í™˜
    logger.warning(f"ì§€ì—­ëª… ë§¤í•‘ ì‹¤íŒ¨: {user_input} (ì›ë³¸ ì‚¬ìš©)")
    return user_input


# ==================== ë˜‘ë˜‘í•œ ê²½ìŸì‚¬ ê²€ìƒ‰ (í´ë°± ì§€ì›) ====================

def find_competitors_smart(
    db_path: str,
    user_area: str,
    user_industry: str,
    limit: int = 5,
    beta: float = 1.8,
    alpha: float = 0.9,
    min_similarity_cutoff: float = 0.50,
    enable_dynamic_cutoff: bool = True,
    min_review_count: int = 30
) -> List[CompetitorScore]:
    """
    ì—…ì¢… í´ë°± ì§€ì› + ë™ì  ì»·ì˜¤í”„ + ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™”
    
    Args:
        db_path: DB ê²½ë¡œ
        user_area: ì§€ì—­
        user_industry: ì—…ì¢…
        limit: ë°˜í™˜í•  ê²½ìŸì‚¬ ìˆ˜
        beta: ì—…ì¢… ê°€ì¤‘ì¹˜ (ê¸°ë³¸ 1.8)
        alpha: ì§€ì—­ ê°€ì¤‘ì¹˜ (ê¸°ë³¸ 0.9)
        min_similarity_cutoff: ìµœì†Œ ì—…ì¢… ìœ ì‚¬ë„ (ê¸°ë³¸ 0.5)
        enable_dynamic_cutoff: ê²°ê³¼ ë¶€ì¡± ì‹œ ì»·ì˜¤í”„ ìë™ í•˜í–¥ (ê¸°ë³¸ True)
        min_review_count: ìµœì†Œ ë¦¬ë·° ìˆ˜ (ê¸°ë³¸ 30)
    
    Returns:
        ê²½ìŸì‚¬ ë¦¬ìŠ¤íŠ¸ (CompetitorScore)
    """
    logger.info("="*60)
    logger.info("ğŸ” ê²½ìŸì‚¬ ê²€ìƒ‰ ì‹œì‘")
    logger.info("="*60)
    
    # 1. ì…ë ¥ ê²€ì¦
    if not user_area or not user_industry:
        logger.error("âŒ ì§€ì—­ ë˜ëŠ” ì—…ì¢…ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
        return []
    
    # 2. ì§€ì—­ëª… ì •ê·œí™”
    normalized_area = normalize_area(user_area)
    logger.info(f"ğŸ“ ì§€ì—­: {user_area} â†’ {normalized_area}")
    
    # 3. ì—…ì¢… í´ë°± ì²´ì¸ ìƒì„±
    fallback_chain = INDUSTRY_HIERARCHY.get(user_industry, [user_industry, 'ìŒì‹ì '])
    logger.info(f"ğŸ´ ì—…ì¢… í´ë°± ì²´ì¸: {' â†’ '.join(fallback_chain)}")
    
    # 4. DB ì—°ê²° (ì˜ˆì™¸ ì²˜ë¦¬)
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
    except sqlite3.Error as e:
        logger.error(f"âŒ DB ì—°ê²° ì‹¤íŒ¨: {e}")
        return []
    
    # 5. DBì—ì„œ ê°€ê²Œ ê°€ì ¸ì˜¤ê¸°
    try:
        cursor.execute("""
            SELECT place_id, name, district, industry, review_count
            FROM stores
            WHERE review_count >= ?
            ORDER BY review_count DESC
        """, (min_review_count,))
        
        all_stores = cursor.fetchall()
        
        if not all_stores:
            logger.warning(f"âš ï¸  ë¦¬ë·° {min_review_count}ê°œ ì´ìƒì¸ ê°€ê²Œê°€ ì—†ìŠµë‹ˆë‹¤")
            return []
        
        logger.info(f"ğŸ“Š ì´ {len(all_stores):,}ê°œ ê°€ê²Œ ê²€ìƒ‰ ì¤‘...")
        
    except sqlite3.Error as e:
        logger.error(f"âŒ DB ì¿¼ë¦¬ ì‹¤íŒ¨: {e}")
        conn.close()
        return []
    finally:
        conn.close()
    
    # 6. ì ìˆ˜ ê³„ì‚°
    logger.info(f"âš™ï¸  ê°€ì¤‘ì¹˜: Î²={beta} (ì—…ì¢…), Î±={alpha} (ì§€ì—­)")
    logger.info(f"âœ‚ï¸  ì»·ì˜¤í”„: ì—…ì¢… ìœ ì‚¬ë„ â‰¥ {min_similarity_cutoff}")
    
    scored_stores = []
    current_cutoff = min_similarity_cutoff
    
    for store in all_stores:
        try:
            place_id, name, district, industry, review_count = store
            
            # í´ë°± ì²´ì¸ ì¤‘ ê°€ì¥ ìœ ì‚¬í•œ ì—…ì¢… ì°¾ê¸°
            max_similarity = 0.0
            best_match_industry = industry
            match_type = "ì •í™• ì¼ì¹˜"
            
            for idx, fallback_industry in enumerate(fallback_chain):
                similarity = get_industry_similarity_score(fallback_industry, industry)
                if similarity > max_similarity:
                    max_similarity = similarity
                    best_match_industry = fallback_industry
                    
                    if idx == 0:
                        match_type = "ì •í™• ì¼ì¹˜"
                    elif idx <= 2:
                        match_type = f"ìœ ì‚¬ ì—…ì¢… ({fallback_industry})"
                    else:
                        match_type = f"ëŒ€ì²´ ì—…ì¢… ({fallback_industry})"
            
            # ì»·ì˜¤í”„ í•„í„°
            if max_similarity < current_cutoff:
                continue
            
            # ì§€ì—­ ì í•©ë„
            geo_fitness = get_geo_fitness_score(normalized_area, district)
            
            # ìµœì¢… ì ìˆ˜
            competition_score = calculate_competition_score(max_similarity, geo_fitness, beta, alpha)
            
            scored_stores.append(CompetitorScore(
                place_id=place_id,
                name=name,
                district=district,
                industry=industry,
                review_count=review_count,
                industry_similarity=max_similarity,
                geo_fitness=geo_fitness,
                competition_score=competition_score,
                match_type=match_type
            ))
            
        except Exception as e:
            logger.warning(f"âš ï¸  ì ìˆ˜ ê³„ì‚° ì‹¤íŒ¨ (ê°€ê²Œ: {name}): {e}")
            continue
    
    # 7. ë™ì  ì»·ì˜¤í”„ (ê²°ê³¼ ë¶€ì¡±í•˜ë©´ ì»·ì˜¤í”„ ë‚®ì¶¤)
    if enable_dynamic_cutoff and len(scored_stores) < limit:
        attempts = 0
        while len(scored_stores) < limit and current_cutoff > 0.25 and attempts < 3:
            current_cutoff -= 0.15
            logger.info(f"ğŸ”» ê²°ê³¼ ë¶€ì¡± â†’ ì»·ì˜¤í”„ í•˜í–¥: {current_cutoff:.2f}")
            
            # ì¬ê³„ì‚°
            for store in all_stores:
                try:
                    place_id, name, district, industry, review_count = store
                    
                    # ì´ë¯¸ ì¶”ê°€ëœ ê°€ê²ŒëŠ” ìŠ¤í‚µ
                    if any(s.place_id == place_id for s in scored_stores):
                        continue
                    
                    max_similarity = 0.0
                    best_match_industry = industry
                    match_type = "ëŒ€ì²´ ì—…ì¢…"
                    
                    for idx, fallback_industry in enumerate(fallback_chain):
                        similarity = get_industry_similarity_score(fallback_industry, industry)
                        if similarity > max_similarity:
                            max_similarity = similarity
                            best_match_industry = fallback_industry
                            
                            if idx <= 2:
                                match_type = f"ìœ ì‚¬ ì—…ì¢… ({fallback_industry})"
                            else:
                                match_type = f"ëŒ€ì²´ ì—…ì¢… ({fallback_industry})"
                    
                    if max_similarity < current_cutoff:
                        continue
                    
                    geo_fitness = get_geo_fitness_score(normalized_area, district)
                    competition_score = calculate_competition_score(max_similarity, geo_fitness, beta, alpha)
                    
                    scored_stores.append(CompetitorScore(
                        place_id=place_id,
                        name=name,
                        district=district,
                        industry=industry,
                        review_count=review_count,
                        industry_similarity=max_similarity,
                        geo_fitness=geo_fitness,
                        competition_score=competition_score,
                        match_type=match_type
                    ))
                    
                except Exception as e:
                    continue
            
            attempts += 1
    
    # 8. ì •ë ¬
    scored_stores.sort(key=lambda x: (x.competition_score, x.review_count), reverse=True)
    
    # 9. ìƒìœ„ Nê°œ ë°˜í™˜
    top_competitors = scored_stores[:limit]
    
    # 10. ê²°ê³¼ ì¶œë ¥
    if not top_competitors:
        logger.warning(f"âš ï¸  ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê²½ìŸì‚¬ê°€ ì—†ìŠµë‹ˆë‹¤")
        logger.info(f"   ğŸ’¡ ì œì•ˆ: min_similarity_cutoffë¥¼ ë‚®ì¶”ê±°ë‚˜ ì§€ì—­ ë²”ìœ„ë¥¼ ë„“í˜€ë³´ì„¸ìš”")
        return []
    
    logger.info(f"âœ… ê²½ìŸì‚¬ {len(top_competitors)}ê°œ ë°œê²¬!")
    for i, comp in enumerate(top_competitors, 1):
        logger.info(f"   {i}. {comp.name} ({comp.district}, {comp.industry})")
        logger.info(f"      â””â”€ Score: {comp.competition_score:.3f} "
                   f"[ì—…ì¢…: {comp.industry_similarity:.2f}, ì§€ì—­: {comp.geo_fitness:.2f}] "
                   f"[{comp.review_count}ê°œ] [{comp.match_type}]")
    
    return top_competitors


# ==================== ì„¤ëª… ìƒì„± ====================

def generate_competitor_selection_explanation(
    beta: float = 1.8,
    alpha: float = 0.9,
    cutoff: float = 0.50
) -> str:
    """ë¦¬í¬íŠ¸ìš© ì„¤ëª… ë¬¸êµ¬"""
    return f"""## ğŸ“ ê²½ìŸì‚¬ ì„ ì • ë°©ë²•ë¡ 

### ìˆ˜ì‹
```
ìµœì¢… ê²½ìŸ ì ìˆ˜ = (ì—…ì¢… ìœ ì‚¬ë„)^{beta} Ã— (ì§€ì—­ ì í•©ë„)^{alpha}
```

### ì—…ì¢… ìœ ì‚¬ë„ (0~1)
- **1.00**: ë™ì¼ ì—…ì¢… (ì¹´í˜ vs ì¹´í˜)
- **0.85**: ê±°ì˜ ê°™ìŒ (ì¹´í˜ vs ë””ì €íŠ¸ì¹´í˜)
- **0.75**: ì„¸ë¶€ë§Œ ë‹¤ë¦„ (ì¹´í˜ vs ë¸ŒëŸ°ì¹˜ì¹´í˜)
- **0.60**: ì¸ì ‘ ëŒ€ì²´ (ì¹´í˜ vs ë² ì´ì»¤ë¦¬)
- **0.40**: ì•½í•œ ëŒ€ì²´ (ì¹´í˜ vs ìƒŒë“œìœ„ì¹˜)
- **< {cutoff}**: ì œì™¸ (ì˜ˆ: ì¹´í˜ vs ì˜¤ë§ˆì¹´ì„¸)

**í´ë°± ì²´ì¸**: DBì— ì •í™•í•œ ì—…ì¢…ì´ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ìœ ì‚¬ ì—…ì¢… ê²€ìƒ‰
- ì˜ˆì‹œ: ì•„ê·€ì°œ â†’ í•´ë¬¼ì°œ â†’ ì°œë¥˜ â†’ í•œì‹ â†’ ìŒì‹ì 

**ìˆ ì§‘ í†µí•©**: ìˆ ì§‘, ì£¼ì , ìš”ë¦¬ì£¼ì , í˜¸í”„ì§‘, ë°”, í, í¬ì°¨ â†’ ëª¨ë‘ 0.8~0.9 ìœ ì‚¬ë„

### ì§€ì—­ ì í•©ë„ (0~1)
- **1.00**: ë™ì¼ ìŠ¤íŠ¸ë¦½/ë‹¨ì§€ (ì„±ìˆ˜ì¹´í˜ê±°ë¦¬, ê²½ë¦¬ë‹¨ê¸¸)
- **0.85**: ê°™ì€ ê¶Œì—­Â·ë„ë³´ 10ë¶„ (ì—­ 1ì •ê±°ì¥)
- **0.60**: ì¸ì ‘ ê¶Œì—­Â·ë„ë³´ 15ë¶„
- **0.40**: ë‹¤ë¥¸ ê¶Œì—­Â·ëŒ€ì¤‘êµí†µ (ê°•ë‚¨ vs í™ëŒ€)

**ì¥ë²½ íŒ¨ë„í‹°**: í•œê°•/ê³ ê°€/ëŒ€ë¡œ/ëª°ë²½ â†’ Ã—0.75

### ë™ì  ì»·ì˜¤í”„
ê²€ìƒ‰ ê²°ê³¼ê°€ ë¶€ì¡±í•˜ë©´ ì»·ì˜¤í”„ë¥¼ ìë™ìœ¼ë¡œ ë‚®ì¶° ë” ë„“ì€ ë²”ìœ„ì—ì„œ ê²½ìŸì‚¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

### ì˜ˆì™¸ ì²˜ë¦¬
- DB ì—°ê²° ì‹¤íŒ¨ â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
- ì§€ì—­ëª… ë§¤í•‘ ì‹¤íŒ¨ â†’ ì›ë³¸ ì‚¬ìš©
- ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜ â†’ í•´ë‹¹ ê°€ê²Œ ìŠ¤í‚µ
"""


# ==================== í…ŒìŠ¤íŠ¸ ====================

if __name__ == "__main__":
    # ì—…ì¢… ìœ ì‚¬ë„ í…ŒìŠ¤íŠ¸
    print("\n" + "="*60)
    print("ğŸ§ª ì—…ì¢… ìœ ì‚¬ë„ í…ŒìŠ¤íŠ¸")
    print("="*60)
    
    test_pairs = [
        ('ìˆ ì§‘', 'ì£¼ì '),
        ('ìˆ ì§‘', 'ìš”ë¦¬ì£¼ì '),
        ('ìˆ ì§‘', 'í˜¸í”„ì§‘'),
        ('ìˆ ì§‘', 'ë°”'),
        ('ìˆ ì§‘', 'í'),
        ('ì£¼ì ', 'ìš”ë¦¬ì£¼ì '),
        ('ì´ìì¹´ì•¼', 'ìˆ ì§‘'),
        ('ì•„ê·€ì°œ', 'í•´ë¬¼ì°œ'),
        ('ì˜¤ë§ˆì¹´ì„¸', 'ìŠ¤ì‹œ'),
        ('ì¹´í˜', 'ë””ì €íŠ¸ì¹´í˜'),
    ]
    
    for ind1, ind2 in test_pairs:
        score = get_industry_similarity_score(ind1, ind2)
        print(f"   {ind1:12s} â†” {ind2:12s}: {score:.2f}")
    
    # ê²½ìŸì‚¬ ê²€ìƒ‰ í…ŒìŠ¤íŠ¸
    print("\n" + "="*60)
    print("ğŸ§ª ê²½ìŸì‚¬ ê²€ìƒ‰ í…ŒìŠ¤íŠ¸ (ìˆ ì§‘)")
    print("="*60)
    
    competitors = find_competitors_smart(
        db_path='seoul_industry_reviews.db',
        user_area='ê°•ë‚¨ì—­',
        user_industry='í˜¸í”„ì§‘',  # ìˆ ì§‘ ê³„ì—´ í…ŒìŠ¤íŠ¸
        limit=5
    )
    
    print("\nâœ… í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")